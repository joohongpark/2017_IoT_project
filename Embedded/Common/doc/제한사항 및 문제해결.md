# 제한 사항 및 발생한 문제와 해결 로그

## 1. 전력 측정 인터페이스 칩 (ADE7753) 선정 문제 및 전력 산정 과정

ADE7755 -> CS5464 -> ADE7753 순서로 전력 측정 칩을 선정하게 되었다. 그 이유는 ADE7755는 사용법이 과도하게 복잡하였고 CS5464는 의도한 대로 동작하지 않는 경우가 많았다. 따라서 참조 레퍼런스가 많은 ADE7753 칩을 최종 선정하였다.
전력 측정 도입 순서는

> 1. SPI 통신 여부
> 2. 전류 측정 여부
> 3. 전압 측정 여부
> 4. 최종 전력 측정 및 누적 전력량 만족시 인터럽트 발생 여부
> 5. 기존 MCU 환경에 최종 도입

순서로 진행하였다.

SPI 통신 여부 단계에서 ADE7755, CS5464, ADE7753 칩 레퍼런스 회로를 참조하여 SPI 통신을 이용하여 칩 내부 레지스터의 R/W 테스트를 수행하였다. 하지만 알 수 없는 문제로 ADE7755, CS5464 두 칩은 SPI 통신이 잘 되지 않았고 (특히 CS5464 칩은 단순히 SPI 통신만 하는데에도 칩이 타버림) 원인 분석을 시도하였으나 결국 ADE7753으로 바꾸는 방안으로 해결을 하였다.

ADE7753은 두개의 내부 ADC로 전압과 전류 (CT센서로 인해 전류의 세기가 전압의 세기로 변환됨) 를 입력받아 LPF, 위상보정 등을 거쳐 적분기로 들어가 Vrms, Irms, 유효 무효전력 등을 출력해준다. 에너지와 전력 관계 식에 따라 ADE7753은 내부 일정 주기에 따라 적분하며 이를 샘플링이라 칭한다. 또 ADE7753의 기본 샘플링 주기 (T) 는 $\frac{4}{CLKIN}$ (s) (CLKIN = 외부 클럭 (단위 : hz)
)이다. ADE7753에서 외부 클럭을 대략 3.5MHz 단위로 공급하므로 T≈1.1μs가 된다.
ADE7753에서 2개의 ADC를 거친 전압, 전류값은 내부의 필터, 게인 등을 지나 곱해지는데 이 곱해진 값은 에너지 레지스터에 누적이 된다. 따라서 일정한 주기마다 에너지 레지스터를 읽는다면 그것은 에너지(J)가 되고, 시간으로 나눈다면 평균 전력(W)이 나올 것이다.
최종적으로 사용 전력을 구하는 대에 밑 4가지 공식을 사용하였으며 전개를 보면 사실 한 공식이라고 볼 수 있을 것이다.

### 1. $K(Wh/LSB)=\frac{Load(W)  × Accumulation Time(s)}{LAENERGY × 3600(s/h)}$

### 2. $Load(W)=\frac{K(Wh/LSB) × LAENERGY × 3600(s/h)}{Accumulation Time(s)}$

### 3. $Accumulation Time(s)=\frac{LINECYC × Line Period(s)}{2}$

### 4. $Line Period(s)=PERIOD×\frac{8}{CLKIN}$

또 ADE7753 칩은 누적 전력량 만족시 (예를 들어 에너지 레지스터가 Overflow를 일으키거나 하는 상황에 대해) 인터럽트를 발생시키는 기능이 있다.

최종 도입 단계에서 전력 측정에 대한 기준을 선정하는 것에 대한 이슈가 있었다. 인터럽트를 통해 누적 전력량을 채울 때 인터럽트를 발생시켜 전력량을 산정하는 방식과 주기적으로 ADE7753 레지스터에 접근하여 전력량을 가져오는 방법이 있었다. 첫 번째 방법을 택하려고 했으나 해당 기능을 사용할 때 MCU에서 인터럽트 루틴에 대해 처리해야 할 양이 많고 전력을 소비하지 않을 때 전력 산정이 애매하다고 생각되어 두 번째 방안을 택하기로 하였다.

## 2. RF 통신 구성 문제 (nRF24L01)

이 칩을 선정한 이유는 블루투스나 지그비 통신에 비해 모듈 가격이 저렴하며 범용 프로토콜을 사용하지 않아 충돌 가능성이 적고 아주 간단한 데이터 교환만이 필요하므로 기존 프로토콜을 사용할 필요성이 없어서 선정하였다. 하지만 1:n 통신을 부분적으로 지원하고 양방향 통신이 되지 않아 (콘센트가 전력값을 “보내고” 온오프 제어값을 “받아야” 하기 때문에 양방향 통신을 지원해야 함) 자체적으로 1:n 양방향 통신이 되게 프로토콜을 구성하었다.

기본적인 통신은 nRF24L01 내부의 독자 프로토콜인 Enhanced ShockBurst™ 을 이용하였고, 다음 그림과 같이 데이터 파이프라인의 형태로 통신이 이루어진다.

![출처 : nRF24L01 Datasheet](./pipe.png)

그림에서 보듯이 1대다 통신이 1:6까지 지원이 되지 않는다. 여기서 주목하여야 할 점은 data pipe를 통한 통신에 TX, RX 어드레스가 있음에 주목하여야 하며 1:N 통신을 위해 이 점을 이용하였다.

nRF24L01의 기본적인 Enhanced ShockBurst™ 프로토콜의 통신 순서는 각각의 TX, RX 디바이스가 해당 모드로 들어갈 때 TX 모듈은 TX주소(예를 들어 1), RX주소(예를 들어 1) 두 가지를 가진다. 또 RX 모듈은 RX 주소 (예를 들어 2) 한 가지만 가진다.

먼저 1이라는 TX 주소를 가진 TX가 2라는 주소를 가진 RX에게 데이터 패킷을 보낸다. (1 -> 2) RX는 패킷을 수신하였으면 곧바로 ACK 패킷을 송신하는데 보내는 주소는 1번이 될 것이다. 왜냐 하면 데이터 패킷 내엔 TX, RX 주소가 다 들어있기 때문에 보낸 주소로 다시 보내는게 RX가 TX를 식별할 수 있는 유일한 표식이기 때문이다. 따라서 RX는 TX와 RX 주소가 같아야 ACK 패킷 까지도 송수신이 가능하다.

이렇게 TX와 RX 모듈이 고정되어 있는 상황에서 난 먼저 TX, RX가 송수신을 끝낼 때 인터럽트가 발생함을 이용하여 서로 송, 수신을 마치면 주소를 서로 바꾸는 방법을 사용하였다. 이 문제를 사용해서 발생한 문제는 주소를 서로 바꿀 때 동일한 RX 주소를 가지고 있는 디바이스가 존재할 수 밖에 없어 다른 디바이스는 고유의 RX 주소만 가지고 있게 하였고 주소를 바꿀 때에 충돌이 생기지 않게 해결하였다.

두번째로 1:n 통신을 가능케 하기 위해 TX 디바이스가 다른 디바이스에 접속할때 RX 주소도 그에 맞게 바꿈으로써 1:6을 넘어 최대 1:255 (혹은 그 이상)까지 통신이 가능하게 만들었다. 구현 언어는 MCU 프로그래밍 언어인 C를 이용해 구현하였다.